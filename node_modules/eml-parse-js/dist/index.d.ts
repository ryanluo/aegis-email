import { Base64 } from 'js-base64';
import { convert, decode, encode } from './charset';
import { GB2312UTF8, mimeDecode, getBoundary } from './utils';
import { EmailAddress, ParsedEmlJson, ReadedEmlJson, Attachment, BuildOptions, CallbackFn, OptionOrNull, BoundaryRawData, BoundaryConvertedData, BoundaryHeaders } from './interface';
/**
 * create a boundary
 */
declare function createBoundary(): string;
/**
 * Builds e-mail address string, e.g. { name: 'PayPal', email: 'noreply@paypal.com' } => 'PayPal' <noreply@paypal.com>
 * @param {String|EmailAddress|EmailAddress[]|null} data
 */
declare function toEmailAddress(data?: string | EmailAddress | EmailAddress[] | null): string;
/**
 * Gets character set name, e.g. contentType='.....charset='iso-8859-2'....'
 * @param {String} contentType
 * @returns {String|undefined}
 */
declare function getCharset(contentType: string): string | undefined;
/**
 * Gets name and e-mail address from a string, e.g. 'PayPal' <noreply@paypal.com> => { name: 'PayPal', email: 'noreply@paypal.com' }
 * @param {String} raw
 * @returns { EmailAddress | EmailAddress[] | null}
 */
declare function getEmailAddress(rawStr: string): EmailAddress | EmailAddress[] | null;
/**
 * decode section
 * @param {String} str
 * @returns {String}
 */
declare function unquoteString(str: string): string;
/**
 * Decodes 'quoted-printable'
 * @param {String} value
 * @param {String} charset
 * @param {String} qEncoding whether the encoding is RFC-2047â€™s Q-encoding, meaning special handling of underscores.
 * @returns {String}
 */
declare function unquotePrintable(value: string, charset?: string, qEncoding?: boolean): string;
/**
 * Parses EML file content and returns object-oriented representation of the content.
 * @param {String} eml
 * @param {OptionOrNull | CallbackFn<ParsedEmlJson>} options
 * @param {CallbackFn<ParsedEmlJson>} callback
 * @returns {string | Error | ParsedEmlJson}
 */
declare function parse(eml: string, options?: OptionOrNull | CallbackFn<ParsedEmlJson>, callback?: CallbackFn<ParsedEmlJson>): string | Error | ParsedEmlJson;
/**
 * Convert BoundaryRawData to BoundaryConvertedData
 * @param {BoundaryRawData} boundary
 * @returns {BoundaryConvertedData} Obj
 */
declare function completeBoundary(boundary: BoundaryRawData): BoundaryConvertedData | null;
/**
 * buid EML file by ReadedEmlJson or EML file content
 * @param {ReadedEmlJson} data
 * @param {BuildOptions | CallbackFn<string> | null} options
 * @param {CallbackFn<string>} callback
 */
declare function build(data: ReadedEmlJson | string, options?: BuildOptions | CallbackFn<string> | null, callback?: CallbackFn<string>): string | Error;
/**
 * Parses EML file content and return user-friendly object.
 * @param {String | ParsedEmlJson} eml EML file content or object from 'parse'
 * @param { OptionOrNull | CallbackFn<ReadedEmlJson>} options EML parse options
 * @param {CallbackFn<ReadedEmlJson>} callback Callback function(error, data)
 */
declare function read(eml: string | ParsedEmlJson, options?: OptionOrNull | CallbackFn<ReadedEmlJson>, callback?: CallbackFn<ReadedEmlJson>): ReadedEmlJson | Error | string;
/**
 * if you need
 * eml-format all api
 */
export { getEmailAddress, toEmailAddress, createBoundary, getBoundary, getCharset, unquoteString, unquotePrintable, mimeDecode, Base64, convert, encode, decode, completeBoundary, ParsedEmlJson, ReadedEmlJson, EmailAddress, Attachment, BoundaryHeaders, parse as parseEml, read as readEml, build as buildEml, GB2312UTF8 as GBKUTF8, };
